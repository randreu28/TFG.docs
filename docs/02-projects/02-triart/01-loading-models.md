# Loading 3D models from the cloud

## The usual approach

As seen in the other projects, loading 3D models has been thought of by the 3D libraries we rely on, and it is usually pretty straightforward.

What is usually done is to have the model in a public route, such as https://yoursite.com/model.gltf. This model serves a specific function, and we know what shape it has: The materials it uses, the nodes, the animations, etc. This allows us to write the models in JSX declaratively with the [gltfJSX library](https://github.com/pmndrs/gltfjsx):

<video controls autoplay width="100%">
  <source src="https://user-images.githubusercontent.com/2223602/126318148-99da7ed6-a578-48dd-bdd2-21056dbad003.mp4" type="video/mp4"/>
</video>

But what if you don't know what the model is? What if you have to **evaluate the model at run-time**? This is the case when loading models from the clouds.

The idea of TriArt is based on cloud integration. The user should be able to store their models on the cloud and retrieve them safely. But how are 3D files retrieved and interacted with when you don't know what the models are? Let's go over it!

## Database structure

I won't go over the [Supabase](https://supabase.com/) instance I have set up in too much depth, but what you need to know is that it is a PostgreSQL with a table called ArtWorks that looks similar to this:

| id  |      user_id      | visibility |                                    url |
| :-- | :---------------: | :--------: | -------------------------------------: |
| 1   | 292e4ad19628-9513 |   public   | https://supabase.com/storage/model.glb |

The `id` is the unique key of each row, and the `user_id` is the foreign key that references the user. Then there is the `visibility` column that dictates if the URL generated by TriArt has an authentication bypass or not, and the URL is a simple URL generated by [supabase's storage](https://supabase.com/docs/guides/storage).

## Server Side loading and validation

If you visit https://tfg-triart.vercel.app/artwork/32, for example, you'll notice that the URL structure takes the parameter `id` (in this case, 32) to select and display the chosen artwork.
This, in combination with React Server Components of Next13, allows us to load the chosen artwork and handle the visibility status validation, without any line running on the client:

```tsx
type Props = {
  params: { id: string };
};

export default async function Artwork({ params: { id } }: Props) {
  const {
    data: { session },
  } = await supabase.auth.getSession();

  const { data, error } = await supabase.from("artwork").select().eq("id", id);

  if (data[0].visiblity === "private" && data[0].user_id !== session?.user.id) {
    throw Error("You don't have permission to see this artwork");
  }

  return <Scene url={data[0].url} />;
}
```

## Loading unknown models

As previously discussed, knowing what model will you be working on has a lot of benefits. But what if you don't know what your model will look like? R3F has a way of loading models just by the use of a link (either local or public), with the `useLoader` hook:

```tsx title="R3F example"
import { useLoader } from "@react-three/fiber";
import { GLTFLoader } from "three/examples/jsm/loaders/GLTFLoader";

export default function Scene() {
  //highlight-next-line
  const gltf = useLoader(GLTFLoader, "/Poimandres.gltf");
  return <primitive object={gltf.scene} />;
}
```
